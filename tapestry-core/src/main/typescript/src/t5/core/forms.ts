// Copyright 2012, 2013, 2025 The Apache Software Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http:#www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/** 
 * ## t5/core/forms
 *
 * Defines handlers for HTML forms and HTML field elements, specifically to control input validation.
 * @packageDocumentation
 */
import events from "t5/core/events";
import dom from "t5/core/dom";
import _ from "underscore";
import { ElementWrapper }from "t5/core/types";

// Meta-data name that indicates the next submission should skip validation (typically, because
// the form was submitted by a "cancel" button).
let exports_;
const SKIP_VALIDATION = "t5:skip-validation";

// Data attribute and value added to HTML forms generated by the 
// Tapestry's Form component from the core library.
const DATA_ATTRIBUTE = "data-generator";
const DATA_ATTRIBUTE_VALUE = "tapestry/core/form";
const TAPESTRY_CORE_FORM_SELECTOR = "form[" + DATA_ATTRIBUTE + "='" + DATA_ATTRIBUTE_VALUE + "']";

const clearSubmittingHidden = function(form: ElementWrapper) {
  const hidden = form.findFirst("[name='t:submit']");

  // Clear if found
  hidden && hidden.value(null);

  form.meta(SKIP_VALIDATION, null);

};

const setSubmittingHidden = function(form: ElementWrapper, submitter: ElementWrapper) {

  const mode = submitter.attr("data-submit-mode");
  const isCancel = mode === "cancel";
  if (mode && (mode !== "normal")) {
    form.meta(SKIP_VALIDATION, true);
  }

  let hidden = form.findFirst("[name='t:submit']");

  if (!hidden) {
    const firstHidden = form.findFirst("input[type=hidden]")!;
    hidden = dom.create("input", {type: "hidden", name: "t:submit"});
    firstHidden.insertBefore(hidden);
  }

  const element = submitter.element as HTMLInputElement;

  // TODO: Research why we need id and name and get rid of one if possible.
  const name = isCancel ? "cancel" : element.name;
  // Not going to drag in all of json2 just for this one purpose, but even
  // so, I'd like to get rid of this. Prototype includes Object.toJSON(), but jQuery
  // is curiously absent an equivalent.
  hidden.value(`[\"${element.id}\",\"${name}\"]`);

};

// Passed the element wrapper for a form element, returns a map of all the values
// for all non-disabled fields (including hidden fields, select, textarea). This is primarily
// used when assembling an Ajax request for a form submission.
const gatherParameters = function(form: ElementWrapper) {
  const result = {} as any;

  const fields = form.find("input, select, textarea");

  _.each(fields, function(field) {
      if (field.attr("disabled")) { return; }

      const element = field.element as HTMLInputElement;

      const {
        type
      } = element;

      // Ignore types file and submit; file doesn't make sense for Ajax, and submit
      // is handled by keeping a hidden field active with the data Tapestry needs
      // on the server.
      if ((type === "file") || (type === "submit")) { return; }

      if (((type === "checkbox") || (type === "radio")) && (field.checked() === false)) { return; }

      const value = field.value();

      if (value === null) { return; }

      const {
        name
      } = element;

      // Many modern UIs create name-less elements on the fly (e.g., Backbone); these may be mixed
      // in with normal elements managed by Tapestry but should be ignored (not sent to the server in a POST
      // or Ajax update).
      if (name === "") { return; }

      const existing = result[name];

      if (_.isArray(existing)) {
        existing.push(value);
        return;
      }

      if (existing) {
        result[name] = [existing, value];
        return;
      }

      return result[name] = value;
  });

  return result;
};


const defaultValidateAndSubmit = function(element: ElementWrapper) {

  let where = () => "processing form submission";

  try {

    if (((element.attr("data-validate")) === "submit") &&
        (!element.meta(SKIP_VALIDATION))) {

      let memo;
      element.meta(SKIP_VALIDATION, null);

      let hasError = false;
      let focusField = null;

      for (var field of Array.from(element.find("[data-validation]"))) {
        memo = {} as any;
        where = () => `triggering ${events.field.inputValidation} event on ${field.toString()}`;
        field.trigger(events.field.inputValidation, memo);

        if (memo.error) {
          hasError = true;
          if (!focusField) { focusField = field; }
        }
      }

      // Only do form validation if all individual field validation
      // was successful.
      if (!hasError) {
        memo = {} as any;
        where = () => "trigging cross-form validation event";
        element.trigger(events.form.validate, memo);

        hasError = memo.error;
      }

      if (hasError) {
        clearSubmittingHidden(element);

        // If a specific field has been identified as the source of the validation error, then
        // focus on it.
        if (focusField) { focusField.focus(); }

        // Trigger an event to inform that form validation results in error
        where = () => "triggering validation in error event";
        element.trigger(events.form.validateInError);

        // Cancel the original submit event when there's an error
        return false;
      }
    }

    // Allow certain types of elements to do last-moment set up. Basically, this is for
    // FormFragment, or similar, to make their hidden field enabled or disabled to match
    // their UI's visible/hidden status. This is assumed to work or throw an exception; there
    // is no memo.
    where = () => `triggering ${events.form.prepareForSubmit} event (after validation)`;

    element.trigger(events.form.prepareForSubmit);

  } catch (error: any) {
    console.error(`Form validiation/submit error \`${error.toString()}', in form ${element.toString()}, ${where()}`);
    console.error(error);
    return false;
  }

  // Otherwise, the event is good, there are no validation problems, let the normal processing commence.
  // Possibly, the document event handler provided by the t5/core/zone module will intercept form submission if this
  // is an Ajax submission.
};

dom.onDocument("submit", TAPESTRY_CORE_FORM_SELECTOR, defaultValidateAndSubmit);

// On any click on a submit or image, update the containing form to indicate that the element
// was responsible for the eventual submit; this is very important to Ajax updates, otherwise the
// information about which control triggered the submit gets lost.
dom.onDocument("click", TAPESTRY_CORE_FORM_SELECTOR + " input[type=submit], " + TAPESTRY_CORE_FORM_SELECTOR + " input[type=image]", 
    function(element: ElementWrapper) {
  const form = element.element as HTMLInputElement;
  setSubmittingHidden((dom(form)!), element);
});

// Support for link submits. `data-submit-mode` will be non-null, possibly "cancel".
// Update the hidden field, but also cancel the default behavior for the click.
dom.onDocument("click", "a[data-submit-mode]", function(element: ElementWrapper) {
  const form = element.findParent("form");

  if (!form) {
    console.error("Submitting link element not contained inside a form element.");
    return false;
  }

  setSubmittingHidden(form, element.closest("a[data-submit-mode]")!);

  // Now the ugly part; if we just invoke submit() on the form, it does not trigger
  // the form's "submit" event, which we need.

  form.trigger("submit");

  // And cancel the default behavior for the original click event
  return false;
});

export default {
  gatherParameters,

  setSubmittingElement: setSubmittingHidden,

  // Sets a flag on the form to indicate that client-side validation should be bypassed.
  // This is typically associated with submit buttons that "cancel" the form.
  skipValidation(form: ElementWrapper) {
    return form.meta(SKIP_VALIDATION, true);
  }
};
