 ----
 tapestry-core
 ----
 
Tapestry Core

  The tapestry-core module provides the interfaces and annotations that form the Tapestry API.
  
  tapestry-core is built upon the {{{../tapestry-ioc/index.html}Tapestry IoC Container}}.

Changes from Tapestry 4 to Tapestry 5

  Tapestry 5 represents a significant advance over Tapestry 4.  The goal is to make Tapestry 5
  <significantly> easier to use than Tapestry 4 (or any other Java web framework).
  We're keeping the <essence> of Tapestry 4, but starting with a brand new code base designed
  to provide a stable, powerful, extensible platform for many years to come.
  
  Here's a few of the planned and implemented features:
  
  * Simplified, minimal API based on annotations
  
  * <<No>> base class requirement; components are true, pure Pojos (Plain Old Java Objects)
  
  * Abstract classes ... gone!  Classes are normal, concrete classes.
  
  * <<No>> XML descriptors for pages and components ... just the annotations.
  
  * Less configuration all around.
  
  * Automatic reloading of templates and even <Java classes>
  
  * Super-duper Ajax integration built on {{{http://dojotoolkit.org} Dojo}}
  
  * Easy & fast unit testing of individual pages or components
  
New And Of Note

  Progress on Tapestry 5 is really taking off. This space lists some cool new features that have been added
  recently.
  
  * Validating form components will use the same system as BeanEditForm to determine default validation for fields.
  
  * Select component will automatically provide a ValueEncoder and SelectModel when the value parameter is bound to an Enum type.
  
  * BeanEditForm component that creates a form and related controls to edit the properties of any JavaBean, automatically.
    Inspired by {{{http://www.trailsframework.org/}Trails}} and {{{http://beanform.sourceforge.net/}BeanForm}} (both for Tapestry 4).
  
  * Case insensitve URLs.  Tapestry no longer cares about the case of the page names and commponent ids it puts
    into URLs, and they are now generated in all lower-case for that clean "Web 2.0" look.  And they're 
    shorter, too!
  
  * Initial support for {{{guide/appstate.html}application state objects}}.
  
  * Input validation messages may now be overriden by providing a particular message key in the containing component's message catalog.
  
  * Property expressions may now reference public methods (with no parameters) in addition to traditional property names.
  
  * Page templates are now allowed to be stored in the WEB-INF , as well as on the classpath.
  
  * Invisible instrumentation, hiding Tapestry components inside ordinary HTML elements (a favorite feature of Tapestry 4), has been added to Tapestry 5.
  
  * Component parameter defaults may be computed on the fly.

  * Component parameters may have default values.
  
Adaptive API

  A key feature of Tapestry 5 is <adaptive API>.
  
  In traditional Java frameworks, including Tapestry 4, user code is expected to
  conform to the framework.  You create classes that extend from framework-provided
  base classes, or implement framework-provided interfaces.
  
  This works well until you upgrade to the next release of the framework: with
  the new features of the upgrade, you will more often than not experience breaks
  in backwards compatibility. Interfaces or base classes will have changed and your
  existing code will need to be changed to match.
  
  In Tapestry 5, the framework <adapts to your code>.  You have control over the
  names of the methods, the parameters they take, and the value that is returned. This
  is driven by annotations, which tell Tapestry under what circumstances your
  methods are to be invoked.
  
  For example, you may have a login form and have a method that gets invoked
  when the form is submitted:
  
+----+
@Persist
private String _userId;

private String _password;

@Component
private Form _form;

@InjectPage
private Start _startPage;

@Inject
private LoginAuthenticator _authenticator;

@OnEvent("submit")
private Object doLogin()
{
  if (_authenticator.isValidLogin(_userId, _password))
    return _startPage;
    
  // Stay on this page:

 _form.recordError("Invalid user name or password."); 
  
  return null;
}
+----+

  This short snippet demonstrates a bit about how Tapestry operates.  Pages and services
  within the application are injected with the @Inject annotation. The @OnEvent
  annotation identifies, to Tapestry, when the method is to be invoked
  (when a form component contained by the page emits a "submit" event). The method's 
  return value directs Tapestry on what to do: jump to another page within the application
  (by returning the injected Start page), or stay on the same page to display the
  error message.
  
  This also represents a distinct change from Tapestry 4. In earlier versions of Tapestry, 
  the Form component's listener parameter would be bound to the method to invoke, by name.  Further,
  the listener method had to be public.
  This new approach not only support multiple listeners, but provides an improved separation of
  view concerns (inside the page's HTML template) and logic concerns, inside the Java class.
    
  In many cases, additional information about the event is available, and can be passed
  into the method by adding parameters to the method. Again, Tapestry will adapt
  to your parameters, in whatever order you supply them.
  
  Finally, Tapestry 5 explicitly seperates actions (requests that change things) and rendering (requests that
  render pages) into two seperate requests.  Performing an action, such as clicking a link or submitting a form,
  results in a <client side redirect> to the new page. This is often called "redirect after post". This helps ensure
  that URLs in the browser are book-markable ... but also requires that a bit more information be stored in the session
  between requests (using the @Persist annotation).  