 ---
  Component Classes
 ----
 
Component Classes

  Component classes in Tapestry 5 are much easier than in Tapestry 4.  There are no base classes to extend from, the classes are concrete (not abstract), and there's no XML file. There is still
  a bit of configuration in the form of Java annotations, but
  those now go directly onto fields of your class, rather than on abstract getters and setters (the case in Tapestry 4).  
  
  Classes for pages, for components and for component mixins are all created in an identical way.

* Component Class Basics

  Creating page and component classes in Tapestry 5 is a breeze.
  
  Unlike Tapestry 4, in Tapestry 5, component classes are not <abstract>, nor do
  they extend from framework base classes. They are pure POJOs (Plain Old Java Objects).
  
  There are only a few constraints:
  
  * The classes must be public.
  
  * The classes must be in the correct package, as per the {{{conf.html}application configuration}}.
  
  * The classes must be annotated with the
  {{{../apidocs/org/apache/tapestry/annotations/ComponentClass.html}ComponentClass}} annotation.
  
  []
  
  Here's a very basic component:
  
  
+----+
package org.example.myapp.components;

import org.apache.tapestry.MarkupWriter;
import org.apache.tapestry.annotations.ComponentClass;
import org.apache.tapestry.annotations.BeginRender;

@ComponentClass
public class HelloWorld
{
    @BeginRender
    void renderMessage(MarkupWriter writer)
    {
        writer.write("Bonjour from HelloWorld component.");
    }
}
+----+  
  
  This component's only job is to write out a fixed message. The
  {{{../apidocs/org/apache/tapestry/annotations/BeginRender.html}BeginRender}} annotation is
  a type of <{{{rendering.html}component lifecycle annotation}}>, a method annotation that instructs
  Tapestry when and under what circumstances to invoke methods of your class.
 
  In another departure from Tapestry 4, these methods are not necessarily public; they
  can have any visibility you like.
  
Component Packages

  Component classes must exist within an appropriate package (this is necessary for runtime code transformation
  and class reloading to operate).
  
  These packages exist under the application's root package.
  
  For pages, place classes in <root>.<<pages>>.  Page names are mapped to classes within this package.
  
  For components, place classes in <root>.<<components>>.  Component types are mapped to classes within this package.
  
  For mixins, place classes in <root>.<<mixins>>.   Mixin types are mapped to classes within this package.
  
  In addition, it is common for an application to have base classes, often <abstract> base classes, that should not be directly referenced. These
  should not go in the <<pages>>, <<components>> or <<mixins>> packages, because they then look like valid pages, components or mixins. Instead,
  use the <root>.<<base>> package to store such base classes.
  
Sub-Folders / Sub-Packages

  Classes do not have to go directly inside the package (pages, components, mixins, etc.). It is valid to create a sub-package 
  to store some of the classes.  The sub-package name becomes part of the page name or component type.  Thus you might define a page component 
  <<<com.example.myapp.pages.admin.CreateUser>>> and the logical page name (which often shows up inside URLs) will be <<admin/CreateUser>>.
  
Pages vs. Components

  The distinction in Tapestry 5 between pages and component is very, very small.  The only
  real difference is the package name:  <root>.<<pages>>.<PageName> for pages,
  and <root>.<<components>>.<ComponentType> for components.
  
  In Tapestry 4, there was a much greater distinction between pages
  and components, which showed up as seperate interfaces and a hierarchy of
  abstract implementations to extend your classes from.
  
  In Tapestry 5, the "page" is still somewhat present, but is really
  an internal Tapestry class. Page components are simply the <root component> of a page's
  component tree.
  
Class Transformation

  Tapestry uses your class as a starting point. It <transforms> your class at runtime. This is necessary
  for a number of reasons, including to address how Tapestry pools pages between requests.
  
  For the most part, these transformations are both sensible and invisible. In a few limited cases, they
  are maginally {{{http://www.joelonsoftware.com/printerFriendly/articles/LeakyAbstractions.html}leaky}} -- for instance,
  the requirement that instance variables be private -- but we feel that the programming
  model in general will support very high levels of developer productivity.
  
  Because transformation doesn't occur until <runtime>, the build stage of your application is not
  affected by the fact that you are creating a Tapestry application. Further, your classes are absolutely
  simple POJOs during testing.
  
Class Reloading

  Component classes are monitored for changes by the framework. 
  {{{reload.html}Classes are reloaded when changed.}} This allows you to build your application
  with a speed approaching that of a scripting environment, without sacrificing any of the power
  of the Java platform.
  
Instance Variables

  Tapestry components may have instance variables (unlike Tapestry 4, where you had to 
  use <abstract properties>). 
  
  <<Instance variables must be private.>> Tapestry must perform runtime class modifications to
  support instance variables, and may only do so for private variables. You may have
  non-private variables in your class, but you may then see unexpected behavior in
  a production application because of how Tapestry pools and reuses pages and components. Tapestry
  will log an error for each component class that contains fields that are neither static nor private.  
  
  Be aware that you will need to provide getter and setter methods to access your classes'
  instance variables. Tapestry <does not> do this automatically.
  
  
  
Transient Instance Variables

  Unless an instance variable is decorated with an annotation, it will be a
  <transient> instance variable. This means that its value resets to its
  default value
  at the end of reach request.
  
  
  <<TODO: Setting an initial value with @OnPageLoad>>
  
Constructors

  Tapestry will instantiate your class using the default, no arguments constructor.  Other constructors will
  be ignored.
  
Injection

  {{{inject.html}Injection}} of dependencies occurs at the field level, via additional annotations.  At runtime,
  fields that contain injections become read-only.
  
Parameters

  {{{parameters.html}Component parameters}} are also identified using private fields of your class, with
  the {{{.../apidocs/org/apache/tapestry/annotations/Parameter.html}Parameter}} annotation.
  
Persistent Fields

  Fields may be annotated so that they {{{persist.html}retain their value across requests}}.  
  
{Embedded Components}

  Components often contain other components.  Components inside another components template are called <embedded components>.  
  The containing component's
  {{{templates.html}template}} will contain \<comp\> element identifying where the the embedded components go.
  
  You can define the type of component inside template, or you can create an instance variable for the component
  and use the
  {{{../apidocs/org/apache/tapestry/annotations/Component.html}Component}} annotation to define the component type
  and parameters.  You should not provide the type attribute of the \<comp\> element, just the id attribute (if you do provide
  the type attribute, Tapestry will log an error and use the type of the annotated field).
  
  Example:
  
+---+
package org.example.app.pages;

import org.apache.tapestry.annotations.Component;
import org.apache.tapestry.annotations.ComponentClass;
import org.example.app.components.Count;

@ComponentClass
public class Countdown
{
    @Component(parameters =
    { "start=5", "end=1", "value=countValue" })
    private Count _count;  
  
    private int _countValue;

    public int getCountValue()
    {
        return _countValue;
    }

    public void setCountValue(int countValue)
    {
        _countValue = countValue;
    }
}  
+---+

  The above defines a component whose embedded id is "count" (this id is derived from the name of the field).  The type
  of component is org.example.app.components.Count.  
  The start and end parameters of the Count component are bound to literal values, and the value
  parameter of the Count component is bound to the countValue property of the Countdown component.
  
  Note that inside the component class, the default binding prefix is always "prop:". 
  In the example we could write <<<"value=prop:countValue">>> if we desired to be
  fully explicit.
  
  However, certain literal values, such as the numeric literals in the example,
  are accepted by the prop: binding prefix even though they are not actually properties (this is largely as a convienience
  to the application developer).  We could also use the "literal:" prefix, <<<"start=literal:5">>> which accomplishes
  largely the same thing.
  
  You may specify additional parameters inside the component template, but parameters in the component class
  take precendence.  
  
  <<TODO: May want a more complex check; what if user uses prop: in the template and there's a conflict?>>
  
  You may override the default component id (as derived from the field name)
  using the id() attribute of the Component annotation.
  
  If you define a component in the component class, and there is no corresponding \<comp\> element in the template,
  Tapestry will log an error.