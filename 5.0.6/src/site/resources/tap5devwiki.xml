<?xml version="1.0"?>
<!-- 
   Copyright 2007 The Apache Software Foundation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->

<rss version="2.0">
<channel>
<title>Tapestry 5 Brain Dump</title>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html</link>
<description>The quick and dirty one-stop shopping of random ideas for Tapestry 5.</description>
<language>en-us</language>
<copyright>Copyright 2007 HowardLewisShip</copyright>
<pubDate>Wed, 31 Jan 2007 21:26:39 GMT</pubDate>
<lastBuildDate>Wed, 31 Jan 2007 21:26:39 GMT</lastBuildDate>
<docs>http://blogs.law.harvard.edu/tech/rss</docs>
<generator>TiddlyWiki 2.0.11</generator>
<item>
<title>DependentParameterDefaults</title>
<description>I've been seeing a number of cases, mostly related to form element components, where I would like to create a smart default for a parameter using the defaultFoo() method (for parameter &quot;foo&quot;).&lt;br /&gt;&lt;br /&gt;The problem is that the parameters are processed in alphabetical order.  Generally, this means that parameter &quot;value&quot; is processed last, and that means that when defaultFoo() is invoked, parameter &quot;value&quot; may not be available.  This only happens in the case where the &quot;value&quot; parameter is unbound and its value is provided via a parameter default method.&lt;br /&gt;&lt;br /&gt;Take Select.  I'd like to be able to generate a default model and default encoder based on the type of the value.  However, if value is left unbound (so as to be defaulted to the matching property of the containing component, via the defaultValue() defaulter method), then the defaulter methods for encoder and model can't query the value parameter's type because its binding is null.&lt;br /&gt;&lt;br /&gt;An ugly fix for this would be to name the value parameter's field _aaa_value to ensure that it is ordered first.  But that's really ugly.&lt;br /&gt;&lt;br /&gt;Instead, I'm thinking of a flag on the Parameter annoation, perhaps named &quot;critical&quot;, that would artifically order the processing of the parameter earlier than others.  So first you process (and generate code for) the criticals, then you generate code for the ordinary parameters.  I think its highly unlikely any component will have more than one critical.&lt;br /&gt;&lt;br /&gt;The end result is that defaultValue() will be called before defaultModel() or defaultEncoder(), which is what I want.  In the final generated class, by the time defaultModel() is invoked, we know for sure what the value binding is.</description>
<category>parameters</category>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#DependentParameterDefaults</link>
<pubDate>Wed, 31 Jan 2007 21:26:39 GMT</pubDate>
</item>
<item>
<title>MasterIndex</title>
<description>Top level concepts within Tapestry 5.&lt;br /&gt;&lt;br /&gt;A //meta-note//: This is where new ideas are first explained, usually before being implemented. In many cases, the final implementation is&lt;br /&gt;not a perfect match for the notes. That's OK ... as long as the official Maven documentation does a good job. It's not reasonable to expect developers to jump back in here and dot every i and cross every t if they're already expected to generate good Maven documentation.&lt;br /&gt;&lt;br /&gt;* PropBinding -- Notes on the workhorse &quot;prop:&quot; binding prefix&lt;br /&gt;* TypeCoercion -- How Tapestry 5 extensibly addresses type conversion&lt;br /&gt;* FormProcessing&lt;br /&gt;* DynamicPageState -- tracking changes to page state during the render&lt;br /&gt;* EnvironmentalServices -- how components cooperate during page render&lt;br /&gt;* ComponentMixins -- A new fundamental way to build web functionality&lt;br /&gt;* RequestTypes -- Requests, request processing, URL formats&lt;br /&gt;* ComponentTemplates -- Issues about Component Templates&lt;br /&gt;* DeveloperProcedures -- Your a Tapestry committer ... how do you makes changes?&lt;br /&gt;* SmartDefaults -- do even more with event less&lt;br /&gt;* RandomIdeas -- stuff that doesn't fit elsewhere&lt;br /&gt;* ProblemsNeedingSolutions&lt;br /&gt;* ComponentDocumentation -- Generating Documentation about Components&lt;br /&gt;* TapestryLookAndFeel -- Default CSS&lt;br /&gt;* [[Assets]]&lt;br /&gt;* CaseInsensitivity -- case in URLs should not matter&lt;br /&gt;* FullReload -- Why limit reloading to just components?&lt;br /&gt;* RelativeURLs -- rendered links should be short and relative to the base URL&lt;br /&gt;* SecureClientState -- securing state stored on the client&lt;br /&gt;* DependentParameterDefaults &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#MasterIndex</link>
<pubDate>Wed, 31 Jan 2007 21:18:11 GMT</pubDate>
</item>
<item>
<title>SecureClientState</title>
<description>In several places, including form submissions, Tapestry stores serialized object data on the client.&lt;br /&gt;&lt;br /&gt;The basic process for this is to serialize the data to a bytestream, compress the bytestream using GZip, then encode the compressed bytestream using MIME BASE64 encoding.&lt;br /&gt;&lt;br /&gt;Later, the process is reversed.&lt;br /&gt;&lt;br /&gt;This is a powerful approach, but introduces two concerns:&lt;br /&gt;&lt;br /&gt;* The MIME encoded string can become quite large (especially for very large and complex forms).  This may impact the use of GET request for forms (where that would be appropriate, such as a search form), and may also prevent applications from executing well on limited platforms such as cell phones and PDAs.&lt;br /&gt;&lt;br /&gt;* A sufficiently clever &quot;black hat&quot; hacker could hijack the serialized bytestream and substitute different serialized objects, towards some kind of mischief.&lt;br /&gt;&lt;br /&gt;An approach to be explored (possibly using an add-in module) would be to store the serialized data on the server, in a flat file or embedded database.&lt;br /&gt;&lt;br /&gt;Only an identifier for the serialized data would be sent to the client.&lt;br /&gt;&lt;br /&gt;The identifier would be &quot;salted&quot; with the user's session id (if available) or perhaps the user's IP address (if no session exists).  Or we would force the creation of a session.&lt;br /&gt;&lt;br /&gt;These ideas raise some new concerns related to clustering, especially if sticky sessions are not used.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;In my opinion, it is highly unlikely that any significant compromise could be accomplished in this way.</description>
<category>request</category>
<category>state</category>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#SecureClientState</link>
<pubDate>Sat, 20 Jan 2007 14:20:00 GMT</pubDate>
</item>
<item>
<title>RelativeURLs</title>
<description>Currently, in T4, when Tapestry creates a URL to an asset, or to an action or page, it generates a complete URI (that is, the URL with the scheme and hostname portion stripped off).&lt;br /&gt;&lt;br /&gt;However, Tapestry could quite reasonably, compare the request's base URL to the URI for the link, and shorten it from an absolute path to a relative path.&lt;br /&gt;&lt;br /&gt;For instance, when rendering /context/admin/AdminMenu.html, a link to /context/images/admin/border.png could ultimately show up in the HTML as ../../images/admin/border.png.&lt;br /&gt;&lt;br /&gt;This would be especially handy for action events; /context/admin/AdminMenu.action/form  would be rendered out as just AdminMenu.action/form.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#RelativeURLs</link>
<pubDate>Sat, 20 Jan 2007 14:03:00 GMT</pubDate>
</item>
<item>
<title>PageRenderRequest</title>
<description>Page render requests are requests used to render a specific page.  //render// is the term meaning to compose the HTML response to be sent to the client. Note: HTML is used here only as the most common case, other markups are entirely possible.&lt;br /&gt;&lt;br /&gt;In many cases, pages are stand-alone.  No extra information in the URL is necesarry to render them.  PersistentProperties of the page will factor in to the rendering of the page.&lt;br /&gt;&lt;br /&gt;In specific cases, a page needs to render within a particular context. The most common example of this is a page that is used to present a specific instance of a database persistent entity. In such a case, the page must be combined with additional data, in the URL, to identify the specific entity to access and render.&lt;br /&gt;&lt;br /&gt;! URI Format&lt;br /&gt;&lt;br /&gt;{{{&lt;br /&gt;/page-name.html/id&lt;br /&gt;}}}&lt;br /&gt;&lt;br /&gt;Here &quot;page-name&quot; is the LogicalPageName for the page. &lt;br /&gt;&lt;br /&gt;The &quot;.html&quot; file extension is used as a delimiter between the page name portion of the URI, and the context portion of the URI. This is necessary because it is not possible (given the plethora of libraries and folders) to determine how many slashes will appear in the URI.&lt;br /&gt;&lt;br /&gt;The context consists of one ore more ids (though a single id is the normal case). The id is used to identify the specific data to be displayed. Further, a page may require multiple ids, which will separated with slashes. Example: /admin/DisplayDetail.html/loginfailures/2006&lt;br /&gt;&lt;br /&gt;Note that these context values, the ids, are simply //strings//. Tapestry 4 had a mechanism, the DataSqueezer, that would encode the type of object with its value, as a single string, and convert it back. While seemingly desirable, this facility was easy to abuse, resulting in long and extremely ugly URIs.&lt;br /&gt;&lt;br /&gt;Any further information needed by Tapestry will be added to the URI as query parameters. This may include things like user locale, persistent page properties, applicaition flow identifiers, or anything else we come up with.&lt;br /&gt;&lt;br /&gt;! Request Processing&lt;br /&gt;&lt;br /&gt;Once the page and id parameters are identified, the corresponding page will be loaded.&lt;br /&gt;&lt;br /&gt;Tapestry will fire two events before rendering the page.&lt;br /&gt;&lt;br /&gt;The first event is of type &quot;activate&quot;.  This allows the page to process the context (the set of ids). This typically involves reading objects from an external persistent store (a database)&lt;br /&gt;and storing those objects into transient page properties, in expectaion of the render.&lt;br /&gt;&lt;br /&gt;This has been implemented, see the reference documentation for more details on passivate/activate.&lt;br /&gt;</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#PageRenderRequest</link>
<pubDate>Sat, 20 Jan 2007 13:48:00 GMT</pubDate>
</item>
<item>
<title>FullReload</title>
<description>It has occured to me that by adding yet another smart class loader, we could possibly set up a system where we track date time modified on all the modules, service interfaces, and implementation files loaded by the Registry, such that changes to any of the files could result in a kind of &quot;soft reload&quot;, where we reload the changed files and construct and use a new Registry.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#FullReload</link>
<pubDate>Tue, 16 Jan 2007 14:50:00 GMT</pubDate>
</item>
<item>
<title>CaseInsensitivity</title>
<description>One aspect of &quot;pretty&quot; URLs for Tapestry pages is that case should not matter.  The user should be able to manually type a URL without respect to case, and have it //just work//.  Turns out that's hard on a number of fronts.&lt;br /&gt;&lt;br /&gt;! Page Names&lt;br /&gt;&lt;br /&gt;In Tapestry 4 and in the current Tapestry 5 code base, that is a problem.  Tapestry starts with a page name, and uses that to hunt around and locate the page class and from there, the page template, etc.&lt;br /&gt;&lt;br /&gt;That hunting around tends to be problematic, because ClassLoader.getResource() is case //specific//.  In addition, ClassLoader doesn't directly provide any way to introspect the available classes.&lt;br /&gt;&lt;br /&gt;You'd think that you could, as a page is first accesssed, record its name in a case insensitve cache somewhere.  However, that doesn't work.  First, in a cluster, the server handling the request may simply never have handled a request for that page before, so it won't have an up-to date cache.  Likewise, after a server restart, existing requests (possibly cached in a browser's bookmarks) &lt;br /&gt;&lt;br /&gt;However, I've been doing some research.  ClassLoader.getResources() , passed a folder name (such as &quot;org/example/myapp/pages/&quot;) will yield one or more URLs for the folders.  Some of these will be URLs for file systems, some will be URLs for JARs.  You can differentiate by the value returned from URL.openConnection().&lt;br /&gt;&lt;br /&gt;For file system URLs, opening the stream provides a list of the files and folders for that package.  Using this, we can identify the protential classes, and identify sub-folders/sub-packages to recursively scan.&lt;br /&gt;&lt;br /&gt;For JAR URLs, we can cast to JARURLConnection and obtain the JarFile instance for the entire JAR.  From there we can obtain a list of entries.&lt;br /&gt;&lt;br /&gt;Combining these two approaches should allow us, at application startup, to locate all page instances.  We'll be able to build a case-insensitive mapping from logical page name to Java class name.&lt;br /&gt;&lt;br /&gt;! Component Ids&lt;br /&gt;&lt;br /&gt;Component ids and id paths show up in some URLs (primarily action URLs, but even so). As currently implemented, ids are case sensitive. With some work, it should be possible to make accessing a component by its id, or id path, case insensitive.  This should include errors if two components have the same case-insensitive id.&lt;br /&gt;&lt;br /&gt;! Query Parameters&lt;br /&gt;&lt;br /&gt;Not sure this is as relevant, because the types of URLs that matter will usually not include any query parameters.  In terms of form submissions ... well, the entire client side is wired case sensitivly, so making form submissions case inensitive seems like a useless exercise.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#CaseInsensitivity</link>
<pubDate>Fri, 05 Jan 2007 19:34:00 GMT</pubDate>
</item>
<item>
<title>ComponentTemplates</title>
<description>There are some issues related to component templates.&lt;br /&gt;&lt;br /&gt;Firstly, people are really interested in seeing the return of InvisibleInstrumentation.  =That is coming.= That is now available.&lt;br /&gt;&lt;br /&gt;Secondly, the idea that templates are well-formed XML documents is causing some issues.&lt;br /&gt;&lt;br /&gt;The problem is related to entities and doctypes.&lt;br /&gt;&lt;br /&gt;Unless you provide a doctype for the template, [[entities|http://www.htmlhelp.com/reference/html40/entities/]] don't work; they result in template parse errors.&lt;br /&gt;&lt;br /&gt;If you provide a standard doctype, say&lt;br /&gt;{{{&lt;br /&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&lt;br /&gt;            &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;&lt;br /&gt;}}}&lt;br /&gt;&lt;br /&gt;You also get parse errors, because the DTD does some odd things with comments that the Java SAX parser doesn't seem to understand.&lt;br /&gt;&lt;br /&gt;I've had better luck with the XHTML doctype:&lt;br /&gt;{{{&lt;br /&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&lt;br /&gt;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;br /&gt;}}}&lt;br /&gt;&lt;br /&gt;But this doesn't render quite the way I want it to.&lt;br /&gt;&lt;br /&gt;Further, entities in the text are converted to unicode by the parser, then converted to //numeric// entities on output.  Not quite WYSIWYG and potentially confusing.&lt;br /&gt;&lt;br /&gt;It may be necessary to discard SAX and build a limited XML parser that allows entities to be passed through unchanged (they would become a special type of document token).&lt;br /&gt;&lt;br /&gt;Lastly, the question is how to get the correct DOCTYPE into the rendered output, espcially in the common case that a Border component provides the outer tags, as is common in Tapestry 4.  This may have to be configured as a annotation on page classes.&lt;br /&gt;&lt;br /&gt;! Template Location&lt;br /&gt;&lt;br /&gt;Concensus is building that templates should //not//  have a  {{{.html}}} extension, but something specific to Tapestry, perhaps {{{.tap}}} or {{{.tsp}}}.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Further, there are invalid, but present, security concerns that the templates should live on the classpath or in WEB-INF, but not in the root folder.  Both of these issues would simplify things for Tapestry.&lt;br /&gt;</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#ComponentTemplates</link>
<pubDate>Fri, 05 Jan 2007 19:19:00 GMT</pubDate>
</item>
<item>
<title>SmartDefaults</title>
<description>As great as the annotations are, allowing things to work without the annotations could be even better.&lt;br /&gt;&lt;br /&gt;!Event handler methods&lt;br /&gt;&lt;br /&gt;Methods with the prefix &quot;on&quot; could automatically be considered event handler methods.  The string after the prefix, converted to lower case, would be the event type.  We could even add &quot;from//~ComponentId//&quot; to the end.  Examples (with annotation equivalents):&lt;br /&gt;&lt;br /&gt;* onSubmit  --&gt; @~OnEvent(&quot;submit&quot;)&lt;br /&gt;* onSubmitFromForm --&gt; @~OnEvent(value=&quot;submit&quot;, component=&quot;form&quot;)&lt;br /&gt;* onUpdateFromSelect  --&gt; @~OnEvent(value=&quot;update&quot;, component=&quot;select&quot;)&lt;br /&gt;* onEventFromSelect --&gt; @~OnEvent(component=&quot;select&quot;)&lt;br /&gt;&lt;br /&gt;This is now implemented.&lt;br /&gt;&lt;br /&gt;!Render phase methods&lt;br /&gt;&lt;br /&gt;Naming a method the same as the render phase (with the first character lower case).  Again, Tapestry could deduce the phase from the method name, as if the annotation were present:&lt;br /&gt;&lt;br /&gt;* beforeRender() --&gt; @~BeforeRender&lt;br /&gt;* beforeRenderBody() --&gt; @~BeforeRenderBody&lt;br /&gt;&lt;br /&gt;etc.  Again, the methods don't have to be public, they just have to have the correct name. In every other way they are the same as annotated render phase methods except that they don't have the annotation.&lt;br /&gt;&lt;br /&gt;There may be some minor implications w.r.t. render phase method ordering.&lt;br /&gt;&lt;br /&gt;etc.&lt;br /&gt;&lt;br /&gt;This is now implemented.&lt;br /&gt;&lt;br /&gt;!Other Ideas&lt;br /&gt;&lt;br /&gt;This gets more component specific. I had the idea that a ~TextField whose id was &quot;userId&quot; might want to edit a property named &quot;userId&quot; as the default for when its value parameter is unbound. I think to accomplish this, we need the concept of computed bindings for unbound parameters ... perhaps in the form of methods that return a Binding with a name and/or annotation, for example:&lt;br /&gt;&lt;br /&gt;{{{&lt;br /&gt;&lt;br /&gt;  @Inject&lt;br /&gt;  private ComponentResources _resources;&lt;br /&gt;&lt;br /&gt;  @Inject(&quot;infrastructure:bindingSource&quot;)&lt;br /&gt;  private BindingSource _source;&lt;br /&gt;&lt;br /&gt;  @Parameter&lt;br /&gt;  private Object _value;&lt;br /&gt;&lt;br /&gt;  Binding defaultValue()&lt;br /&gt;  {&lt;br /&gt;    ComponentResources containerResources = _resources.getContainer().getComponentResources();&lt;br /&gt;    return _source.newBinding(&quot;default value&quot;, containerResources,  _resources.getId());  &lt;br /&gt;  }&lt;br /&gt;}}}&lt;br /&gt;&lt;br /&gt;This is now implemented; very handy for a few things such as TextField.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;So valueDefault() is invoked if the value parameter is not bound.  The component uses its own immediate id (&quot;userId&quot;) as the name of a property of its container (typically, the page).  ~ComponentResources does not yet implement getContainer(), but the rest would work.&lt;br /&gt;&lt;br /&gt;If this was widespread, there could be even better optimizations for it.  Perhaps container resources could just be passed into the method as a parameter, to save the code to find it.  Ditto with BindingSource.  Once again, rather than come up with complex XML-ese to come up with defaults, we're trying to work //with// Java code.&lt;br /&gt;</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#SmartDefaults</link>
<pubDate>Wed, 03 Jan 2007 23:53:00 GMT</pubDate>
</item>
<item>
<title>ProblemsNeedingSolutions</title>
<description>There are a few things that I'm concerned about.&lt;br /&gt;&lt;br /&gt;!Render Complexity&lt;br /&gt;&lt;br /&gt;All those states in the render component state machine may be a little much, especially ~PreBeginRender, ~BeginRender and ~PostBeginRender.  In addition, it doesn't work for a case I'm interested in ... for link components, I'd like to use the RenderInformals mixin, but also support a disable parameter that turns off the &lt;a&gt; tag (but still renders the body).  The state machine currently is set up so that returning false in any of the ~BeginRender states skips all the way to ~AfterRender, bypassing the template and/or body.&lt;br /&gt;&lt;br /&gt;Still don't have a perfect solution for the above (it may not be solvable via mixins, which may show limitations in the component/mixin model).  I have added a @MixinAfter annotation which simplifies the state machine somewhat.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#ProblemsNeedingSolutions</link>
<pubDate>Wed, 03 Jan 2007 23:51:00 GMT</pubDate>
</item>
<item>
<title>Assets</title>
<description>The concept of Assets is unchanged from Tapestry 4.&lt;br /&gt;&lt;br /&gt;There will be an &quot;exclusion list&quot; of file name extensions. Files with that extension will require an md5sum as part of the URI.  The default exclusion list with be &quot;.class&quot;. For other file types (particularily .js, .css, etc.) the file will be the file, and relative file names will work.&lt;br /&gt;&lt;br /&gt;Some kind of hook will be necessary to support schemes like Akamai, where assets are stored externally. This should also take into account localization.&lt;br /&gt;&lt;br /&gt;Some kind of folder aliasing will be necessary.  I may want &quot;/assets/dojo/&quot; to map on the classpath to &quot;/org/apache/tapestry/dojo/dojo_0_0_4/&quot;.  When handling updates to big packages such as Dojo, I don't want to have to sort through some ungodly number of changes between 0.0.4 and 0.0.5, I want to create a new dojo_0_0_5 folder, drop the contents in, delete the dojo_0_0_4 folder, and update the mapping of &quot;/assets/dojo/&quot;.&lt;br /&gt;&lt;br /&gt;Update: the aliasing is in place and very nice; the default CSS stylesheet is &quot;/asset/tapestry/default.css&quot;  not &quot;/asset/org/apache/tapestry/default.css&quot;.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#Assets</link>
<pubDate>Wed, 03 Jan 2007 23:50:00 GMT</pubDate>
</item>
<item>
<title>TapestryLookAndFeel</title>
<description>I think it would be very compelling to create a reasonably sharp default CSS for Tapestry applications. Something pretty, standards based, Web-2.0-ish, that would make even the simplest apps stand out.&lt;br /&gt;&lt;br /&gt;Of course, the Tapestry default CSS would be the first stylesheet, and could be overridden by additional stylesheets or inline styles.&lt;br /&gt;&lt;br /&gt;Have a head start on this, but its controversial.  </description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#TapestryLookAndFeel</link>
<pubDate>Wed, 03 Jan 2007 23:49:00 GMT</pubDate>
</item>
<item>
<title>ComponentMixins</title>
<description>One of the more exciting ideas in Tapestry 5 is //mixins//; the ability to add behavior to a component without writing code. &lt;br /&gt;&lt;br /&gt;It is expected that much common behavior, especially for form control components, will be provided by mixins. Further, many Ajax techniques will take the form of mixins applied to otherwise ordinary components.&lt;br /&gt;&lt;br /&gt;A mixin is an additional component class that operates //with// the main component. For a component element within the page, the functionality is provided by the main component class and by&lt;br /&gt;the mixin.  &lt;br /&gt;&lt;br /&gt;Mixins are primarily about rendering. Mixin render methods are //mixed in// to the components' render methods. In effect, the different rendering phases of a component are different AOP-like //joinpoints//, and the mixins can provide //before advice//.&lt;br /&gt;&lt;br /&gt;Mixins can be specified for an //instance// of a component, or can be specified as part of the //implementation// of a component.&lt;br /&gt;&lt;br /&gt;In the former case, the @Component annotation will be supplemented with a @Mixin annotation. The @Mixin is a list of one or more mixin classes for that component.&lt;br /&gt;&lt;br /&gt;==''Todo: Template syntax for mixins?''== The mixins attribute allows a comma-separated list of component mixins names (logical names, not class names).&lt;br /&gt;&lt;br /&gt;In the latter case, the @ComponentClass annotation will be supplemented with a @Mixin annotation.&lt;br /&gt;&lt;br /&gt;Mixins can be configured.  They can have parameters, just like ordinary components. When a formal parameter name is ambiguous, it will be prefixed with the unqualified class name. Thus, you might have to say, &quot;MyMixin.parameterName=someProperty&quot; if &quot;parameterName&quot; is ambiguous (by ambiguous, we mean, a parameter of more than one mixin or of the component itself).  &lt;br /&gt;&lt;br /&gt;This disambiguation is //simple//. It is assumed that the unqualified class name will be sufficient to uniquely identify a mixin. That is, it is expected that you will not have the same class name even in different packages (as mixins, on a single component). In a //degenerate case// where this is not so, it will be necessary to disambiguate the mixin name by create a subclass of the mixin with a new name.&lt;br /&gt;&lt;br /&gt;==''Todo: how are mixins on a component implementation configured?''== The @Mixin and @MixinClass annotations, on fields, support this.&lt;br /&gt;&lt;br /&gt;Mixins may have persistent state, just as with ordinary components.&lt;br /&gt;&lt;br /&gt;</description>
<category>mixins</category>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#ComponentMixins</link>
<pubDate>Wed, 03 Jan 2007 23:48:00 GMT</pubDate>
</item>
<item>
<title>RandomIdeas</title>
<description>!HTML / XHTML DTDs&lt;br /&gt;&lt;br /&gt;The template parser should include local (in JAR) copies of the HTML and XHTML DTDs and redirect the parser to use the local copies. This can be a huge performance boost when parsing a template.&lt;br /&gt;&lt;br /&gt;!final should imply @Retain&lt;br /&gt;&lt;br /&gt;Final fields should be treated as if they have the @Retain annotation&lt;br /&gt;&lt;br /&gt;! Exceptions from event handler / phase render methods&lt;br /&gt;&lt;br /&gt;Tapestry should wrap non-runtime exceptions from these methods. I think today, if you declare that such a method throws an exception, you'll get a runtime exception out of Javassist.&lt;br /&gt;&lt;br /&gt;! SubForms&lt;br /&gt;&lt;br /&gt;Perhaps one way to approach highly dynamic, Ajax pages with forms is to have a logical &quot;sub form&quot; concept. A sub form would work inside an existing form, and organize a group of fields within that form. Processing of the fields would occur only if the sub form was active, which itself&lt;br /&gt;would be tracked based on visibility of the sub form (a sub form in an invisible panel would not be processed on the server side).  This idea needs a lot of fleshing out, even to see if it is viable.&lt;br /&gt;&lt;br /&gt;! Ajax Constraints&lt;br /&gt;&lt;br /&gt;The best way to tackle Ajax features, especially w.r.t. forms, is to put some sensible constraints on what the user can do, then make it easy to implement those things.&lt;br /&gt;&lt;br /&gt;Basically ... never delete!  Deletions are a real pain to handle, unless I suddenly get much smarter.  Allow things to be hidden on the client side,&lt;br /&gt;and for the corresponding fields to do nothing on the server side, but don't allow them to full out delete. &lt;br /&gt;&lt;br /&gt;Allow new things to be added, preferable only at the &quot;tail end&quot; of the form. &lt;br /&gt;&lt;br /&gt;! SPI Package&lt;br /&gt;&lt;br /&gt;A number of interfaces, such as Binding, probably belong in a SPI (Service Provider Interface) package, since they will generally only be used by authors of Tapestry extensions.  Perhaps we should just use the oat.services package as the SPI package?&lt;br /&gt;&lt;br /&gt;! Deducing Component Types&lt;br /&gt;&lt;br /&gt;Seems to me that a &lt;form&gt; element with a t:id should be a Form component.  Likewise, &lt;input type=&quot;text&quot; t:id=&quot;foo&quot;/&gt; should be a TextField component.  A basic set of rules, via a configuration, could allow for a number of cases (mostly related to input controls) to //do the right thing//.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#RandomIdeas</link>
<pubDate>Wed, 03 Jan 2007 23:46:00 GMT</pubDate>
</item>
<item>
<title>WatchCodeCoverage</title>
<description>The code coverage tools built into ''mvn site'' are quite useful. Right now, overall coverage is at 93%. Keep an eye on code coverage, including branch coverage (do you test both outcomes of an if statement?).  Use unexecuted code to target your efforts.&lt;br /&gt;&lt;br /&gt;I often do a cursory unit test for &quot;normal behavior&quot;, plus more exaustive unit tests for error conditions.  I then &quot;back the test up&quot; using an integration test (build with [[Selenium]]) to prove that the normal behavior case really works.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#WatchCodeCoverage</link>
<pubDate>Fri, 24 Nov 2006 19:57:00 GMT</pubDate>
</item>
<item>
<title>FocusOnTesting</title>
<description>I'm still not at the stage of test first, but with every line of code I write, I am thiking about how I will test that line of code.  Tapestry uses EasyMock extensively, and there's lots of existing code examples to work with.&lt;br /&gt;&lt;br /&gt;!Dont Despair&lt;br /&gt;&lt;br /&gt;I occasionally get exhausted by the amount of test code I write for simple chunks of code.  And I inevitably find a broken line of code that would be a major pain to locate inside a running application, but easy inside a unit test. Keep your eyes on the big picture.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#FocusOnTesting</link>
<pubDate>Fri, 24 Nov 2006 19:54:00 GMT</pubDate>
</item>
<item>
<title>DontTouchInternals</title>
<description>Very few of the Tapestry committers will need to touch anything inside the internals package.  When this occurs, some online discussion may be mandated.  The goal of Tapestry is to ensure that most work for commiters and for developers is in the domain of creating components, not tinkering with internals.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#DontTouchInternals</link>
<pubDate>Fri, 24 Nov 2006 19:53:00 GMT</pubDate>
</item>
<item>
<title>DynamicPageState</title>
<description>Tapestry 4 has left tracking of dynamic page state as an exercise to the developer.  Mostly, this is done using the ''parameters'' parameter of the ~DirectLink component.&lt;br /&gt;&lt;br /&gt;''Update: As I've thought this one through, I don't think it is viable outside of Forms. It will end up with long URLs and a constant ambiguity about whether each link should include or exclude the page state.  So this one is unlikely to get implemented.''&lt;br /&gt;&lt;br /&gt;Dynamic page state is anything that isn't inside a persistent page property. For the most part, this includes page properties updated by a For component&lt;br /&gt;&lt;br /&gt;It seems likely that this information could be automatically encoded into ~URLs.  &lt;br /&gt;&lt;br /&gt;I'm envisioning a service that accumulates a series of //commands//. Each command is used to store a bit of page state. The commands are serializable.  The commands are ultimately serialized into a MIME string and attached as a query parameter to each URL.&lt;br /&gt;&lt;br /&gt;When such a link is triggered, the commands are de-serialized and each executed in turn. Only when that is finished is any further event processing executed, including calling into to user code.&lt;br /&gt;&lt;br /&gt;My outline for this is to store a series of tuples; each tuple is a component id plus the command to execute.&lt;br /&gt;&lt;br /&gt;{{{&lt;br /&gt;public interface ComponentCommand&lt;T&gt;&lt;br /&gt;{&lt;br /&gt;  void execute(T component);&lt;br /&gt;}&lt;br /&gt;}}}&lt;br /&gt;&lt;br /&gt;These commands should be immutable.&lt;br /&gt;&lt;br /&gt;So a component, such as a For loop component, could provide itself and a ComponentCommand instance (probably a static inner class) to some kind of PageStateTracker service.&lt;br /&gt;&lt;br /&gt;{{{&lt;br /&gt;public interface PageStateTracker&lt;br /&gt;{&lt;br /&gt;  void &lt;T&gt; addCommand(T component, ComponentCommand&lt;T&gt; command);&lt;br /&gt;}&lt;br /&gt;}}}&lt;br /&gt;&lt;br /&gt;The commands are kept in the order that they are added, except that new commands for the same component //replace// previous commands for that component.&lt;br /&gt;&lt;br /&gt;As with the Tapestry 4 For component, some mechanism will be needed to store object ids inside the URLs (that is, inside the commands serialized into URL query parameters) and translate back to //equivalent// objects when the link is triggered.&lt;br /&gt;&lt;br /&gt;Dynamic page state outside of a Form will overlap with some of the FormProcessing inside the form.</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#DynamicPageState</link>
<pubDate>Fri, 24 Nov 2006 18:32:00 GMT</pubDate>
</item>
<item>
<title>ComponentDocumentation</title>
<description>Tapestry needs a JavaDoc-like, or JavaDoc-based tool to extract documentation about component parameters (and mixins) and present it in a useable format.  In Tapestry 4, you could document the public getters and setters, but in Tapestry 5, the annotations are on the private instance variables, which are generally not documented.</description>
<category>parameters</category>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#ComponentDocumentation</link>
<pubDate>Thu, 23 Nov 2006 15:34:00 GMT</pubDate>
</item>
<item>
<title>WorkInYourOwnBranch</title>
<description>Working in the trunk can be a problem. ''The SVN trunk is where merges happen, not where development happens.''&lt;br /&gt;&lt;br /&gt;For any bit of code change you make, you want to do the following:&lt;br /&gt;&lt;br /&gt;* Branch trunk to form your own sandbox&lt;br /&gt;* Work in the sandbox&lt;br /&gt;* Ensure high quality: high code coverage, unit and integration tests, up-to-date documentation&lt;br /&gt;* Announce (on the developer mailing list) that you are committing to trunk&lt;br /&gt;* Switch your workspace back to trunk&lt;br /&gt;* Tag trunk as premerge&lt;br /&gt;* Merge from your sandbox&lt;br /&gt;* Ensure a good merge (including documentation, tests, and code coverage)&lt;br /&gt;* Commit your merge to trunk&lt;br /&gt;* Tag trunk as postmerge&lt;br /&gt;&lt;br /&gt;!Branch names&lt;br /&gt;&lt;br /&gt;Branch names should consist of your user id, the current date as YYYYMMDD, and a short mneumonic, such as a bug id.  Example:  {{{hlship-20061027-removeaspectj}}}.&lt;br /&gt;&lt;br /&gt;There's a branches folder for tapestry5/tapestry-core, i.e. [http://svn.apache.org/viewvc/tapestry/tapestry5/tapestry-core/branches/]&lt;br /&gt;&lt;br /&gt;!Tag names&lt;br /&gt;&lt;br /&gt;Prefix the branch name with &quot;premerge&quot; or &quot;postmerge&quot;.  i.e. [http://svn.apache.org/viewvc/tapestry/tapestry5/tapestry-core/tags/]&lt;br /&gt;&lt;br /&gt;These are really important when trying to back out a change, the pre and the post give a lot of context to see what actually changed.&lt;br /&gt;&lt;br /&gt;!Announcing&lt;br /&gt;&lt;br /&gt;Merging is hard enough, it's worse if two people are making possibly conflicting changes at the same time. A little coordination goes a long way.&lt;br /&gt;&lt;br /&gt;!Small increments are ''Good''&lt;br /&gt;&lt;br /&gt;This looks like a lot of overhead, but thanks to Subversion, it really isn't. It's still better to do small increments of work. Don't go away for six months and expect an easy job of committing changes. You can do this style of work several times a day (Subversion was created specifically to make tagging, branching, and merging fast).</description>
<link>http://tapestry.apache.org/tapestry5/tap5devwiki.html#WorkInYourOwnBranch</link>
<pubDate>Sat, 28 Oct 2006 15:36:00 GMT</pubDate>
</item>
</channel>
</rss>