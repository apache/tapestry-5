 ----
 Tapestry IoC Services
 ----
 
Tapestry IoC Services

  Services consist of two main parts: a service interface and a service implementation.
  
  The service interface is how the service will be represented throughout the rest of the
  registry. Since what gets passed around is normally a proxy, you can't expect to cast a service
  object down to the implementation class (you'll see a ClassCastException instead). In other
  words, you should be careful to ensure that your service interface is complete, since
  Tapestry IoC effectively walls you off from backdoors such as casts.
  
  Tapestry doesn't know how to instantiate and configure your service; instead it relies
  on you to provide the code to do so, in a service builder method:
  
+-----------------------------------------------------------------------------------+
package org.example.myapp.services;

public class MyAppModule
{
  public static Indexer build()
  {
    return new IndexerImpl();
  }
}
+-----------------------------------------------------------------------------------+

  Here the service interface is Indexer (presumably inside the org.example.myapp.services package,
  since there isn't an import).  Tapestry IoC doesn't know about the IndexerImpl class (the
  service implementation of the Indexer service), but it does know 
  about the build() method.
  
  That's one of the great innovations of Tapestry IoC: we don't try to encapsulate in XML or annotations
  all the different ways possible to create a service; those things are best expressed in Java code.
  For a simple case (as here), it would be hard for external configuration (again, in XML or Java annotations)
  to be shorter than "new IndexerImpl()".
  
  For more complex and realistic scenarios, such as injecting dependencies via the constructor, or
  doing more interest work (such as registering the newly created service for events published by some other service),
  the Java code is simply the most direct, flexible, extensible and readable approach.
  
Autobuilding

  Tapestry IoC can also <autobuild> your service. Autobuilding is an alternate way to register services
  with the container.
  
  Every module may have an optional, static bind() method which is passed a
  {{{../apidocs/org/apache/tapestry/ioc/ServiceBinder.html}ServiceBinder}}.  Services may be registered with
  the container by "binding" a service interface to a service implementation:
  
+------+
package org.example.myapp.services;

import org.apache.tapestry.ioc.ServiceBinder;

public class MyAppModule
{
  public static void bind(ServiceBinder binder)
  {
    binder.bind(Indexer.class, IndexerImpl.class);
  }
}
+----+

  You can make repeated calls to bind(), to register more services.


  You might ask, "which is better, a builder method for each service, or a bind() method for the module?"  For simple services,
  those that are just an instantiated instance with simple dependencies, binding is better than building.
  
  There are many cases, however, where constructing a service is more than just instantiating a class. Often the new service
  will (for example) be registered as a listener with some other service. In other cases, the implementation of the
  service is generated at runtime. These are where the service builder methods are most useful.

  In terms of the evolution of the framework, service builder methods came first, and autobuilding was a later
  addition, inspired by the terseness of the {{{http://code.google.com/p/google-guice/}Guice}} IoC container.
    
Service Ids

  Every service will have a unique service id. 
  
  When using a service builder method, the service id is the <simple name> of the service interface.
  
  This can be overridden by adding the service id to the method name, after "build", for example:
  
+---+
  public static Indexer buildFileSystemIndexer(@InjectService("FileSystem") FileSystem fileSystem)
  {
     . . .
  }
+----+

  Here, the service id is "FileSystemIndexer" not "Indexer".
  
  For autobuilt services, the service id can be specified when the service is bound:
  
+---+
  binder.bind(Indexer.class, IndexerImpl.class).withId("FileSystemIndexer");
+---+
  
{Injecting Dependencies}

  It's pretty unlikely  that your service will be able to operate in a total vacuum. It will
  have other dependencies.  
  
  Dependencies are provided to a service in one of three ways:
  
  * As parameters to the service builder method
  
  * As parameters to the service implementation class' constructor (for autobuilt services)
  
  * As parameters passed to the constructor of the service's module builder (cached inside instance variables)
  
  []
   
  
  For example, let's say the Indexer needs a JobScheduler to control
  when it executes, and a FileSystem to access files and store indexes.
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(JobScheduler scheduler, FileSystem fileSystem)
  {
    IndexerImpl indexer = new IndexerImpl(fileSystem);
      
    scheduler.scheduleDailyJob(indexer);
      
    return indexer;
  }
+-----------------------------------------------------------------------------------+

  Here we've annotated the parameters of the service builder method to identify what
  service to inject for that parameter.  
  
  This is an example of when you would want to use the service builder method, rather than
  just binding the service interface to the implementation class: because we want to do something extra,
  in this case, register the new indexer service with the scheduler.
  
  Note that we don't invoke those service builder methods ... we just "advertise" that we need
  the named services.  Tapestry IoC will provide the necessary proxies and, when we start to
  invoke methods on those proxies, will ensure that the full service, including its
  interceptors and its dependencies, are ready to go. Again, this is done in a 
  thread-safe manner.   

  What happens if there is more than one service that implements the JobScheduler interface, or
  the FileSystem interface?  You'll see a runtime exception, because Tapestry is unable to resolve
  it down to a <single> service. At this point, it is necessary to <disambiguate> the link between
  the service interface and <one> service.  One approach is to use
  the 
  {{{../apidocs/org/apache/tapestry/ioc/annotations/InjectService.html}InjectService}} annotation:
  
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(@InjectService("JobScheduler")
    JobScheduler scheduler, 
    
    @InjectService("FileSystem")
    FileSystem fileSystem)
  {
    IndexerImpl indexer = new IndexerImpl(fileSystem);
      
    scheduler.scheduleDailyJob(indexer);
      
    return indexer;
  }
+-----------------------------------------------------------------------------------+  
  
  If you find yourself injecting the same dependencies into multiple service builder 
  (or service decorator) methods, you can 
  {{{module.html#Caching Services}cache dependency injections}} in your module, by defining
  a constructor.  This reduces duplication in your module.
 
  
Injecting Dependencies for Autobuilt Services

  With autobuilt services, there's no service builder method in which to specify injections.
  
  Instead, the injections occur on <constructor> for the implementation class:
  
+---+
package org.example.myapp.services;

import org.apache.tapestry.ioc.annotations.InjectService;

public class IndexerImpl implements Indexer
{
  private final FileSystem _fileSystem;
  
  public IndexerImpl(@InjectService("FileSystem") FileSystem fileSystem)
  {
    _fileSystem = fileSystem;
  }
}
+---+  

  If the class has multiple constructors, the constructor with the most parameters will be invoked.
  
  Note how we are using final fields for our dependencies; this is generally a Good Idea.
  These services will often execute inside a multi-threaded environment, such as a web application,
  and the use of final fields inside a constructor ensures that the fields will be properly published
  (meaning, "visible to other threads") in accordance with the Java Memory Model.
  
  Once thing that is not a good idea is to pass in another service, such as JobScheduler in the previous
  example, and pass <<<this>>> from a constructor:
  
+---+
package org.example.myapp.services;

import org.apache.tapestry.ioc.annotations.InjectService;

public class IndexerImpl implements Indexer
{
  private final FileSystem _fileSystem;
  
  public IndexerImpl(@InjectService("FileSystem") FileSystem fileSystem,
  
  @InjectService("JobScheduler") JobScheduler scheduler)
  {
    _fileSystem = fileSystem;
    
    scheduler.scheduleDailyJob(this); // Bad Idea
  }
}
+---+
 
  Understanding why this is a bad idea involves a long detour into inner details of the Java Memory Model.
  The short form is that other threads may end up invoking methods on the IndexerImpl instance, and its fields
  (even though they are final, even though they appear to already have been set) may be uninitialized.
    
Defining Service Scope

  Each service has a <lifecycle> that controls when the service implementation is instantiated.
  There are two built in lifecycles: "singleton" and "perthread", but
  more can be added.
  
  Service lifecycle is specified using the 
  {{{../apidocs/org/apache/tapestry/ioc/annotations/Scope.html}@Scope annotation}},
  which is attached to a builder method.  When this annotation is not present, the
  default scope, "singleton" is used.
    
* singleton
  
  Most services use the default scope, "singleton".  With this scope a <proxy>
  is created when the service is first referenced.  By reference, we mean any situation in which
  the service is requested by name, such as using the @InjectService annotation on a
  service builder method, or by using the
  {{{../apidocs/org/apache/tapestry/ioc/Registry.html}Registry}} API from outside the
  container.
  
  In any case, the service proxy will only create the service implementation when a method
  on the service interface is invoked. Until then, the service can be thought of as "virtual".
  As the first method is invoked, the service builder method is invoked, then any service
  decorations occur.  This construction process, called "realization", occurs only once.
  
  You should be aware when writing services that your code must be thread safe; any service
  you define could be invoked simulataneously by multiple threads. This is rarely an issue
  in practice, since most services take input, use local variables, and invoke methods on other services,
  without making use of non-final instance variables.  The few instance variables
  in a service implementation are usually references to other Tapestry IoC services.
  
* perthread

  The perthread service scope exists primarily to help multi-threaded servlet applications,
  though it has other applications.
  
  With perthread, the service proxy will delegate to a local service instance that is associated
  with the current thread. Two different threads, invoking methods on the same proxy, will
  ultimately be invoking methods on two different service instances, each reserved to their own thread.
  
  This is useful when a service needs to keep request specific state, such as information extracted
  from the HttpServletRequest (in a web application). The default singleton model would not work
  in such a multi threaded environment.  Using perthread on select services allows state to be isolated
  to those services.  Because the dispatch occurs <inside> the proxy, you can treat the service
  as a global, like any other.
  
  You will see that your service builder method is invoked more than once.  It is invoked in each
  thread where the perthread service is used.
  
  At the end of the request, the  Registry's cleanupThread() method is invoked; it will discard
  any perthread service implementations for the current thread.
  
  <<Caution:>> A common technique in Tapestry IoC is to have a service builder method
  register a core service implementation as an event listener with some event hub service.
  With non-singleton objects, this can cause a number of problems; the event hub will
  hold a reference to the per-thread instance, even after that per-thread instance has been
  cleaned up (discarded by the inner proxy). Simply put, this is a pattern to avoid. For
  the most part, perthread services should be simple holders of data specific to a thread or
  a request, and should not have overly complex relationships with the other services
  in the registry.
  
Defining the scope of Autobuilt Services

  There are two options for defining the scope for an autobuilt service.
  
   The service implementation class may include the @Scope annotation. This is generally the preferred way
   to specify scope.
  
  In addition, it is possible to specify the scope when binding the service:
  
+----+
  bind(MyServiceInterface.class, MyServiceImpl.class).scope("perthread");
+----+

    
  
Eager Loading Services

  Services are normally created only as needed (per the scope discussion above).
  
  This can be tweaked slightly; by adding the 
  {{{../apidocs/org/apache/tapestry/ioc/annotations/EagerLoad.html}EagerLoad}} annotation to
  the service builder method, Tapestry will instantiate the service when the Registry is first created.
  
  This will cause the service builder method to be invoked, as well as any service decorator methods.
  
  This feature is used when a service manages a resource, such as a thread, that needs to be created
  as soon as the application starts up.  Another common example is a service that listens for events produced
  by a second service; the first service may need to be created, and start listening, before any of its
  service methods are invoked (which would normally trigger the instantiation of the service).
  
  Many services may be annotated with @EagerLoad; the order in which services are created is not defined. 
  
  With the perthread lifecycle, the service builder method will not be invoked (this won't happen until
  a service method is invoked), but the decorators for
  the service will be created. 
  
Eager Loading Autobuilt Services

  As with service scope, there are two options for indicating that an autobuilt service should be
  eagerly loaded.
  
  The service implementation class may include the @EagerLoad annotation.
  
  You may also specify eager loading explicitly when binding the service:

+----+
  bind(MyServiceInterface.class, MyServiceImpl.class).eagerLoad();
+----+
  
     
Injecting Resources

  In addition to injecting services, Tapestry will key off of the parameter type to allow
  other things to be injected.
  
  * java.lang.String: unique id for the service
    
  * {{{http://www.slf4j.org/api/org/slf4j/Logger.html}org.slf5j.Logger}}: logger for the service
  
  * java.lang.Class: service interface implemented by the service to be constructed
  
  * {{{../apidocs/org/apache/tapestry/ioc/ServiceResources.html}ServiceResources}}:  access to other services
  
  []
  
  No annotation is needed for these cases.
  
  See also {{{configuration.html}service configuration}} for additional special cases
  of resources that can be injected.
  
  Example:
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(String serviceId, Log serviceLog,  
     JobScheduler scheduler, FileSystem fileSystem)
  {
    IndexerImpl indexer = new IndexerImpl(serviceLog, fileSystem);
      
    scheduler.scheduleDailyJob(serviceId, indexer);

    return indexer;
  }
+-----------------------------------------------------------------------------------+  
  
  The order of parameters is completely irrelevant. They can come first or last or be
  interspersed however you like.
  
  Injecting in the ServiceResources can be handy when you want to calculate the name
  of a service dependency on the fly.  However, in the general case (where the
  id of service dependencies is known at build time), it is easier
  to use the @InjectService annotation.
      
  The Log's name (used when configuring logging settings for the service) consists of
  the module class name and the service id seperated by a period, i.e. "org.example.myapp.MyModule.Indexer". 
  
  Further, ServiceResources includes an autobuild() method that allows you to easily trigger
  the construction of a class, including dependencies.  Thus the previos example could be rewritten as:
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(ServiceResources resources, JobScheduler jobScheduler)
  {
    IndexerImpl indexer = resources.autobuild(IndexerImpl.class);
      
    scheduler.scheduleDailyJob(resources.getServiceId(), indexer);

    return indexer;
  }
+-----------------------------------------------------------------------------------+  
  
  This works the exact same way with autobuilt services, except that the parameters of the service
  implementation constructor are considered, rather than the parameters of the service
  builder method.

  The @InjectService annotation takes precendence over these resources.
  
  If the @InjectService annotation is not present, and the parameter type does not exactly match
  a resource type, then {{{provider.html}object injection}} occurs.   Object injection will find the correct
  object to inject based on a number of (extensible) factors, including the parameter type and any additional annotations
  on the parameter.
  
  Every once and a while, you'll have a conflict between a resource type and an object injection.  For example,
  the following does not work as expected:
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(String serviceId, Log serviceLog,  
     JobScheduler scheduler, FileSystem fileSystem,
     @Value("${index-alerts-email}")
     String alertEmail)
  {
    IndexerImpl indexer = new IndexerImpl(serviceLog, fileSystem, alertEmail);
      
    scheduler.scheduleDailyJob(serviceId, indexer);

    return indexer;
  }
+-----------------------------------------------------------------------------------+    

  It doesn't work because type String always gets the service id, as a resource (as with the serviceId parameter).
  In order to get this to work, we need to turn off the resource injection for the alertEmail parameter.
  That's what the {{{../apidocs/org/apache/tapestry/ioc/annotations/Inject.html}Inject}} annotation does:
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(String serviceId, Log serviceLog,  
     JobScheduler scheduler, FileSystem fileSystem,
     @Inject @Value("${index-alerts-email}")
     String alertEmail)
  {
    IndexerImpl indexer = new IndexerImpl(serviceLog, fileSystem, alertEmail);
      
    scheduler.scheduleDailyJob(serviceId, indexer);

    return indexer;
  }
+-----------------------------------------------------------------------------------+      
  
  Here, the alertEmail parameter will recieve the configured alerts email (see
  {{{symbols.html}the symbols documentation}} for more about this syntax) rather than the service id.
  
Builtin Services

  A few services within the Tapestry IOC Module are "builtin"; there is no 
  service builder method
  in the
  {{{../apidocs/org/apache/tapestry/ioc/services/TapestryIOCModule.html}TapestryIOCModule}} class.
  
*---------------------+-----------------------------------------------------------------------------------------+
| <<Service Id>>      | <<Service Interface>>                                                                   |
*---------------------+-----------------------------------------------------------------------------------------+
| ClassFactory        | {{{../apidocs/org/apache/tapestry/ioc/services/ClassFactory.html}ClassFactory}}            |
*---------------------+-----------------------------------------------------------------------------------------+
| LogSource           | {{{../apidocs/org/apache/tapestry/ioc/LogSource.html}LogSource}}                           |
*---------------------+-----------------------------------------------------------------------------------------+
| RegistryShutdownHub | {{{../apidocs/org/apache/tapestry/ioc/RegistryShutdownHub.html}RegistryShutdownHub}}       |
*---------------------+-----------------------------------------------------------------------------------------+
| ThreadCleanupHub    | {{{../apidocs/org/apache/tapestry/ioc/services/ThreadCleanupHub.html}ThreadCleanupHub}}    |
*---------------------+-----------------------------------------------------------------------------------------+

  Consult the JavaDoc for each of these services to identify under what circumstances you'll need to use them.
  
Mutually Dependant Services

  One of the benefits of Tapestry IoC's proxy-based approach to just-in-time instantiation 
  is the automatic support for mutually dependent services.  For example, suppose that
  the Indexer and the FileSystem needed to talk directly to each other.  Normally, this
  would cause a "chicken-and-the-egg" problem: which one to create first?

  With Tapestry IoC, this is not even considered a special case:
  
+-----------------------------------------------------------------------------------+
  public static Indexer build(JobScheduler scheduler, FileSystem fileSystem)
  {
    IndexerImpl indexer = new IndexerImpl(fileSystem);
  
    scheduler.scheduleDailyJob(indexer);
  
    return indexer;
  }
    
  public static build(Indexer indexer)
  {
    return new FileSystemImpl(indexer);
  }  
+-----------------------------------------------------------------------------------+   
  
   Here, Indexer and FileSystem are mutually dependent. Eventually, one or the other
   of them will be created ... let's say its FileSystem. The buildFileSystem() builder
   method will be invoked, and a proxy to Indexer will be passed in.  Inside the
   FileSystemImpl constructor (or at some later date), a method of the Indexer service
   will be invoked, at which point, the builderIndexer() method is invoke. It still receives
   the proxy to the FileSystem service.
   
   If the order is reversed, such that Indexer is built before FileSystem, everything still
   works the same.
   
   This approach can be very powerful: I've (HLS) used it to break apart untestable
   monolithic code into two mutually dependent halves, each of which can be unit tested.
    
   The exception to this rule is a service that depends on itself <during construction>.
   This can occur when (indirectly, through other services) building the service
   trys to invoke a method on the service being built. This can happen when the service
   implemention's constructor invoke methods on service dependencies passed into it,
   or when the service builder method itself does the same. This is actually a very rare
   case and difficult to illustrate.
        